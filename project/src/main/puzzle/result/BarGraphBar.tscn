[gd_scene load_steps=6 format=2]

[ext_resource path="res://assets/main/puzzle/result/box-texture.png" type="Texture" id=2]

[sub_resource type="Shader" id=10]
code = "shader_type canvas_item;
/*
 * Recolors a bar shown in the results screen's bar graph to use a particular set of textures and colors.
 *
 * Each bar graph bar has a unique colored texture or 'accent' which is tiled against a white background. The texture
 * can be resized or recolored. It can also be swapped so that it draws white shapes against a colored background.
 *
 * The shader is applied to a texture which contains a black outlined shape with white inside, and transparent outside.
 * The shader code uses the red channel of the texture to determine where to draw the background accents.
 */

const float PI = 3.14159265358979;

// The size of the node this shader is applied to
uniform vec2 node_size = vec2(100, 100);

// The color of the border, which is black in the source texture
uniform vec4 black : hint_color;

// The color of the middle area, which is white in the source texture
uniform vec4 white : hint_color;

// A monochrome texture containing the accents to draw in the bar's middle
uniform sampler2D accent_texture;

uniform float accent_scale = 0.25;

// Accent texture rotation in degrees
uniform float accent_rotation = 0.0;

// If 'false', the accents will be drawn as colored shapes against a white background. If 'true', the two are swapped
// as white shapes against a colored background.
uniform bool accent_swapped = false;

void fragment() {
	vec4 rgba_in = COLOR;
	
	// Apply the node size, texture size and rotation
	vec2 tex_uv = UV * node_size - node_size;
	tex_uv = tex_uv * mat2(vec2(cos(radians(-accent_rotation)), -sin(radians(-accent_rotation))), vec2(sin(radians(-accent_rotation)), cos(radians(-accent_rotation))));
	tex_uv /= accent_scale * vec2(textureSize(accent_texture, 0));

	// Apply the texture image
	vec4 tex_rgba = accent_swapped ? vec4(1.0) - textureLod(accent_texture, tex_uv, 1.5) : textureLod(accent_texture, tex_uv, 1.5);
	vec4 rgba_out = mix(black, white, rgba_in * tex_rgba.r);

	// preserve transparency of source image
	rgba_out.a *= rgba_in.a;
	COLOR = vec4(rgba_out.rgb, rgba_out.a);
}"

[sub_resource type="ShaderMaterial" id=8]
resource_local_to_scene = true
shader = SubResource( 10 )
shader_param/node_size = Vector2( 100, 100 )
shader_param/black = Color( 0.305882, 0.227451, 0.196078, 1 )
shader_param/white = Color( 0.831373, 0.831373, 0.831373, 1 )
shader_param/accent_scale = 0.25
shader_param/accent_rotation = 0.0
shader_param/accent_swapped = false
shader_param/accent_texture = ExtResource( 2 )

[sub_resource type="StyleBoxFlat" id=9]
resource_local_to_scene = true
bg_color = Color( 1, 1, 1, 1 )
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color( 0, 0, 0, 1 )

[sub_resource type="GDScript" id=11]
script/source = "class_name BarGraphBar
extends Control
## Bar shown in the results screen's bar graph.
##
## The bar graph includes several of these bar nodes stacked on top of each other.

func _ready() -> void:
	connect(\"resized\", self, \"_on_resized\")
	_refresh_node_size()


## When the node is resized, we update the shader so that textures are scaled appropriately.
func _refresh_node_size() -> void:
	material.set_shader_param(\"node_size\", rect_size)


func _on_resized() -> void:
	_refresh_node_size()
"

[node name="Bar1" type="Panel"]
material = SubResource( 8 )
margin_right = 100.0
margin_bottom = 100.0
custom_styles/panel = SubResource( 9 )
script = SubResource( 11 )
